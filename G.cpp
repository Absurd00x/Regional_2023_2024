#pragma GCC optimize("O3")
#include <bits/stdc++.h>

using namespace std;

// Без лонгов

signed main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);

  // Модуль обязательно константный
  const int MOD = 1e9 + 7;

  int n, m;
  cin >> n >> m;
  vector<int> arr(n);
  for (int i = 0; i < n; ++i) {
    cin >> arr[i];
    // Делаем числа равными < m
    --arr[i];
  }

  // Посчитаем сколько каждого числа
  vector<int> cnts(m + 2);
  for (int i = 0; i < n; ++i) {
    ++cnts[arr[i]];
  }

  // Будем проверять, что тройки можно в принципе хоть как-то выбрать
  bool ok = true;
  for (int i = m; i > 1; --i) {
    if (cnts[i] < 0) {
      // Если взяли несуществующее число, то ответа нет
      ok = false;
    } else if (cnts[i] % 3 != 0) {
      // Если количество числа не делится на 3, то мы в любом случае
      // должны будем взять его в тройку с тремя предыдущими числами
      cnts[i - 1] -= cnts[i] % 3;
      cnts[i - 2] -= cnts[i] % 3;
      cnts[i] -= cnts[i] % 3;
    }
  }
  for (int i = 0; i < 2; ++i) {
    if (cnts[i] < 0 || cnts[i] % 3 != 0) {
      // Первые два элемента проверяем отдельно
      ok = false;
    }
  }

  int ans = 0;
  if (ok) {
    // Сокращаем все количества на 3 потому что
    // можно взять либо одно число три раза, либо взять
    // одно, второе и третье по три раза
    for (int i = 0; i < m; ++i) {
      cnts[i] /= 3;
    }
    // dp[i][j][k] = количество способов рассмотреть первые i
    // элементов так, чтобы чисел < i не было, чисел = i было
    // ровно j, а чисел равных i + 1 было ровно k
    // Первое измерение будем писать в два слоя из-за тугих ограничений
    // по памяти на acmp
    vector<vector<vector<int>>> dp(2, vector<vector<int>>(n / 3 + 1, vector<int>(n / 3 + 1)));
    // База динамики, начальное состояние
    dp[0][cnts[0]][cnts[1]] = 1;
    for (int i = 0; i < m; ++i) {
      // Зануляем следующий слой динамики
      for (int j = 0; j <= cnts[i + 1]; ++j) {
        for (int k = 0; k <= cnts[i + 2]; ++k) {
          dp[1][j][k] = 0;
        }
      }
      // Количество элементов в текущем слое обязательно перебираем
      // от большего к меньшему
      for (int j = cnts[i]; j >= 0; --j) {
        for (int k = 0; k <= cnts[i + 1]; ++k) {
          if (j > 0) {
            // Можем взять одну тройку, где все элементы равны i
            dp[0][j - 1][k] += dp[0][j][k];
            dp[0][j - 1][k] %= MOD;
          }
          if (j <= min(k, cnts[i + 2])) {
            // Все оставшиеся числа = j пробуем взять вместе с
            // другими числами. То есть три тройки (i, i + 1, i + 2).
            // Состояния, когда мы возьмём сколько-то троек (i, i, i)
            // обрабатывает первый переход
            dp[1][k - j][cnts[i + 2] - j] += dp[0][j][k];
            dp[1][k - j][cnts[i + 2] - j] %= MOD;
          }
        }
      }
      // Обмениваем слои динамики
      swap(dp[0], dp[1]);
    }
    ans = dp[0][0][0];
  }
  cout << ans << endl;

  return 0;
}
